---

## **MonoRepo 實戰指南：工具選型與 OXC 性能突破**

### 活動跟講者資訊

🔥 JSDC 小聚再追加一位講者！
🚀「跑個 build 要等 5 分鐘？」
🧨「Lint 一跑就去泡咖啡？」
你的開發效率，可能只差一套好工具鏈！
這場 JSDC 小聚，邀請到資深軟體工程師 & 技術 Mentor Michael，帶來最硬核又實用的主題：
MonoRepo 實戰指南：工具選型與 OXC 性能突破
🔧 MonoRepo 工具選型怎麼選？
Turborepo / Nx / pnpm Workspaces 傻傻分不清？
Michael 幫你用「規模對應策略矩陣」一次解惑！
⚡ OXC 是什麼？為何號稱 Lint 界的性能革命？
Vue 3 官方專案都用它、檢查速度可壓在 50ms？！
這場也將帶你拆解傳統工具瓶頸，看看 OXC 如何突破極限！
🎯 最後還有實戰 Bonus：
小 → 大型團隊的選型建議 & ESLint 共存導入路線一次告訴你！
---
👨‍💻 講者介紹｜Michael
資深軟體工程師 / 技術 Mentor
專注前端基建與工具鏈優化，擅長讓團隊升級效能卻不踩坑
信仰：「極致 DX，來自實用選型。」

### **JSDC 2025 小聚 - 20分鐘演講逐字稿**

---

### **🎯 開場**

大家好！我是 Michael，今天很高興在 JSDC 2025 小聚與大家分享一個非常實戰的主題：「MonoRepo 實戰指南：工具選型與 OXC 性能突破」。今天我會用 20 分鐘的時間，帶大家深入了解為什麼 MonoRepo 會成為現代前端開發的必然選擇，以及如何透過 OXC 這個革命性工具來解決性能瓶頸。

---

### **1. 痛點分析**

在進入正題之前，我想先問大家一個問題：你們是否遇到過這樣的情況？早上來到公司，打開電腦，執行 `npm run build`，然後去泡咖啡回來還在跑，接著跑 `npm run lint` 又是漫長的等待，最後 `git push` 之後，CI Pipeline 告訴你還要等 30 分鐘。這聽起來很熟悉對吧？

我想在座各位負責的產品大多經過長久歷史迭代，程式碼數量龐大且架構複雜。更糟的是，這個問題在導入 MonoRepo 之後會變得更加嚴重，因為複雜度是指數級增長的。想像一下：1000 個檔案，乘以 200 條 ESLint 規則，再乘以 50 個 packages，這就是千萬級的運算複雜度！這不是線性增長，而是多維度的複雜度爆炸。

但這個痛點背後，其實反映了一個更深層的趨勢：現代前端開發正面臨前所未有的複雜性挑戰，尤其是前端套件和瀏覽器的更新速度相當快，小至 CSS 語法更新，這些頻繁更新都會造就我們架構上的靈活更動。

---

### **2. 趨勢分析：MonoRepo 必然選擇**

讓我們來分析一下，為什麼 MonoRepo 會成為必然選擇。這背後有三大核心驅動力：

1.  **多平台開發矩陣**：現在的應用開發不再是單純的 Web 開發。我們需要同時支援 Web (React、Vue、Angular)、行動端 (React Native、Flutter、Ionic) 和桌面應用 (Electron、Tauri)。核心問題是：如何在這麼多平台之間有效共享業務邏輯？用戶認證邏輯、資料驗證規則、業務規則、UI 組件庫——這些都需要跨平台復用。

2.  **業務複雜度爆炸**：從架構角度來看，我們現在面對的是後端微服務架構 (用戶服務、支付服務、訂單服務、通知服務)，以及前端的共享組件庫、設計系統、工具庫、CLI 工具。每一個服務、每一個組件庫，如果都用獨立倉庫管理，版本同步會變成噩夢。試想假如有一個靜態 icon 的管理系統是獨立專案，每次更換 icon 都需要同步每個專案的版本，這會是非常惱人的，也會產生許多人為錯誤。

3.  **團隊規模增長挑戰**：讓我們看看團隊規模對開發管理的影響。從新創團隊 (3-5人) 簡單協作，到成長期 (10-20人) 需要強硬規範，再到中型公司 (50-100人) 和大型企業 (200+人) 面臨的協作噩夢。關鍵問題是：如何保證這麼多人、這麼多專案的程式碼品質一致性？這就帶出了版本同步地獄、知識孤島問題、重複造輪子、工具配置分歧等一系列挑戰。

---

### **3. 架構對比：MultiRepo vs MonoRepo**

現在讓我們具體對比一下 MultiRepo 和 MonoRepo 的差別。

在 MultiRepo 架構中，當你要修復一個共享組件的 bug 時，流程是這樣的：首先，在 `shared-components` 倉庫修復 bug；接著，發布新版本到 npm；然後，在 4 個使用這個組件的專案中更新依賴；每個專案都要跑一次完整的 CI/CD；最後，祈禱沒有 breaking changes。這個過程可能需要一整天，而且風險很高。

但在 MonoRepo 中，同樣的修復只需要：修改 `shared/components/Button.tsx`，一次 commit 就能驗證所有使用方。MonoRepo 在版本管理、依賴更新、程式碼復用方面都有明顯優勢。

---

### **4. 目前的 MonoRepo 工具鏈分析，比較差異**

既然 MonoRepo 有這麼多優勢，那麼我們來看看現有的工具選項。但首先，我要告訴大家一個重要的變化：「**Lerna 已死，pnpm 當立**」。

根據 2024 年的最新數據顯示：
*   **Lerna 使用率暴跌**：從 25% 降至 22%，已被 yarn Workspaces 和 npm Workspaces (均為 26%) 超越。
*   **滿意度崩塌**：從 60% 降至 48%，反映開發者對傳統工具的期望正在改變。
*   **維護狀況**：Lerna 已不再積極維護，社群無法及時回應問題。

相對地，**pnpm** 展現出強勁的成長動能：
*   **使用率激增**：從 13% 上升到 21%，呈現明顯上升趨勢。
*   **滿意度領先**：高達 90% 以上的滿意度，與 Turborepo 並列第一。
*   **技術優勢**：50%+ 更快的依賴安裝速度，獨特的硬連結存儲機制大幅節省磁碟空間。

在現代工具選型矩陣中：
*   **Nx** 適用於大型企業 (50+ 人)，核心優勢是依賴圖分析、智慧增量建構和豐富的插件生態，但學習曲線陡峭。
*   **Turborepo** 適用於中型團隊 (10-30 人)，具有革命性快取機制、雲端共享快取和極簡配置，學習曲線平緩.
*   **pnpm Workspaces** 適用於輕量級專案 (5-15 人)，提供原生 MonoRepo 支援、極速安裝和零額外依賴，學習曲線極簡。

**為什麼 pnpm Workspaces 成為新寵**：
1.  **原生支援**：pnpm 本身就預置了對 MonoRepo 的完整支援，無需額外的第三方套件。
2.  **性能卓越**：硬連結機制使得相同版本的依賴只需存儲一份，大幅節省磁碟空間和安裝時間。
3.  **生態成熟**：Vue 3、Vite、Element UI、Varlet UI 等主流開源專案都已採用 pnpm + MonoRepo 的開發模式。
4.  **配置簡潔**：只需一個 `pnpm-workspace.yaml` 檔案即可完成 MonoRepo 配置。

但是，無論選擇哪個工具，它們都有一個共同的死穴：**性能瓶頸**。

---

### **5. 性能瓶頸分析**

讓我們來看看這個數學真相：
```typescript
interface PerformanceBottleneck {
  readonly files: number
  readonly rules: number
  readonly packages: number
  get complexity(): number {
  return this.files * this.rules * this.packages;
  }
}
```
一個典型的 MonoRepo：1000 個檔案 × 200 條規則 × 50 個 packages = **千萬級複雜度**！這帶來三大核心問題：
1.  **ESLint 瓶頸**：每個工具都要重複解析 AST。
2.  **CI/CD 爆炸**：Pipeline 時間過長。
3.  **配置複雜**：多工具整合困難。
這就是為什麼我們需要一個革命性的解決方案。

---

### **6. OXC 革命性解決方案**

這個解決方案就是 **OXC - Oxidation Compiler Collection**。Oxlint 1.0 就是這個計劃的一部分，一個用 Rust 開發的 JavaScript 程式碼檢查工具。

OXC 的核心優勢是：
*   **50-100倍** 速度提升
*   **80%** 記憶體減少
*   **一次** AST 解析
*   **原生** 並行處理

關鍵在於「**統一 AST 的革命**」。傳統工具鏈的問題是：ESLint 解析一次、Prettier 解析一次、Babel 解析一次、TypeScript 又解析一次。同一個檔案要解析 4 次！而 OXC 只解析一次，然後讓所有工具復用同一個 AST。這就是為什麼能有數十倍的性能提升。

Oxlint 1.0 宣稱比 ESLint 快 50-100 倍，比 Biome 快 2 倍。實際效能測試顯示，在零配置情況下，Oxlint 表現最佳，比 Biome 快 0.03 倍，比 ESLint 快 0.17 倍。即便是有配置檔案的測試中，雖然 Biome 略快於 Oxlint 且發現的錯誤更多，但影片作者偏好 Oxlint 的錯誤顯示方式。值得一提的是，其他 Rust 驅動的檢查工具如 Deno Lint 和 RSLint 甚至比 Oxlint 更快，這可能解釋了它們沒有被包含在官方基準測試中。

Oxlint 的其他優勢包括：
*   **功能特色**：擁有自己的規則集，支援超過 500 個 ESLint 規則，並提供 VS Code、WebStorm 和 Zed 的擴充功能。
*   **採用情況**：已被近 6,000 個不同的程式庫使用，包括 Shopify、Airbnb 和 Mercedes-Benz 等知名公司的專案。

讓我們看看真實的企業案例：
*   **Shopify**：500 萬行程式碼，從 75 分鐘降到 10 秒。
*   **Airbnb**：126,000+ 檔案，7 秒完成檢查。
*   **Mercedes-Benz**：71% 時間節省。
這些都是真實的、可驗證的性能提升。

---

### **7. 實戰整合指南 (Oxlint)：一般專案與 Nx MonoRepo 如何漸進式導入**

那麼如何在實際專案中整合 OXC 呢？

#### **一般專案的整合方式**
**基礎整合 (最小痛點)**：
1.  **安裝 Oxlint**：`npm install -D oxlint` 或 `pnpm add -D oxlint`。
2.  **修改 package.json**：在 `scripts` 中增加 `"lint": "oxlint && eslint ."`, `"lint:fix": "oxlint && eslint . --fix"`。
3.  **整合 lint-staged (推薦)**：在 `lint-staged` 配置中加入 `"**/*.{js,ts,jsx,tsx}": ["oxlint", "eslint --fix"]`。

**進階整合 (避免重複檢查)**：
1.  **安裝 eslint-plugin-oxlint**：`npm install -D eslint-plugin-oxlint`。
2.  **ESLint 配置 (Flat Config)**：在 `eslint.config.js` 中引入 `oxlint` 並使用 `...oxlint.configs['flat/recommended']`，這會自動禁用重複規則。

#### **Nx MonoRepo 的整合方式**
**當前最佳實踐 (立即可用)**：
1.  **在根目錄安裝 Oxlint**：在 Nx workspace 根目錄執行 `npm install -D oxlint`。
2.  **修改根目錄 package.json**：將 `lint` script 設定為 `"lint": "oxlint && nx affected:lint --uncommitted --fix --parallel"`，並可增加 `"lint:all": "oxlint && nx run-many -t lint --fix --parallel"`。
3.  **整合 lint-staged**：在 `lint-staged` 中加入 `"**/*.{js,ts,jsx,tsx}": ["oxlint", "nx affected:lint --uncommitted --fix --parallel"]`。
4.  **CI/CD 配置**：在 `.github/workflows/ci.yml` 中，可以在 `Lint` 步驟中先運行 `oxlint`，再運行 `nx affected:lint --base=origin/main --head=HEAD --parallel`。

**Nx 專案層級配置 (可選)**：
*   在特定專案的 `project.json` 中，可以在 `targets` 的 `lint` 執行器中配置 `oxlint {projectRoot}/**/*.{js,ts,jsx,tsx}` 和 `nx lint {projectName} --eslint-config=.eslintrc.json`。

#### **未來升級路徑 (最小痛點遷移)**
*   **階段一：社群插件時期 (預計 2025 年中)**：預期的社群解決方案為 `@nx-community/oxlint`，升級方式是將 `lint` script 從 `oxlint && nx affected:lint...` 改為 `nx affected -t oxlint && nx affected:lint...`。
*   **階段二：Nx 官方支援時期 (預計 2025 年底-2026 年)**：Nx 2025 路線圖重點是 Nx Core 遷移至 Rust，效能優化為核心目標，為 Oxlint 整合鋪路。預期的官方整合是 `@nx/oxlint`，升級方式是將 `lint` script 改為 `nx affected:oxlint && nx affected:lint...`。
*   **階段三：完全整合時期 (長期願景)**：最終理想的單一指令是 `"lint": "nx affected:lint --engine=oxlint,eslint"`。

#### **遷移工具與自動化**
*   **Oxlint 官方遷移工具**：`oxlint-migrate` (`npx oxlint-migrate`) 可以自動分析現有 ESLint 配置，生成對應的 Oxlint 配置，並識別不相容的規則提供建議。
*   **配置兼容性檢查**：可以使用 `oxlint --print-config` 和 `eslint --print-config` 來檢查 Oxlint 的覆蓋率。

#### **風險控制與回退策略**
*   **漸進式採用策略**：
    *   **第一週：測試階段**：`"lint:test": "oxlint"` (僅測試，不影響現有流程)，`"lint": "eslint ."` (保持原有流程)。
    *   **第二週：並行運行**：`"lint": "oxlint && eslint ."` (雙重檢查，確保一致性)。
    *   **第三週：正式採用**：`"lint": "oxlint && eslint ."` (享受效能提升)，並保留 `"lint:fallback": "eslint ."` 作為回退選項。
*   **回退機制**：可以透過環境變數控制 (`USE_OXLINT`) 或 CI/CD 的彈性配置 (`OXLINT_ENABLED`) 來決定是否啟用 Oxlint，確保可隨時回退。

#### **效能監控與優化**
*   **效能基準測試**：建立基準可使用 `time nx run-many -t lint --parallel` 測試 ESLint 效能，並使用 `time (oxlint && nx run-many -t lint --parallel)` 測試 Oxlint + ESLint 效能。
*   **預期效能提升**：一般專案可達 5-10 倍速度提升，Nx MonoRepo 可達 10-50 倍速度提升。對於大型專案 (8k+ 檔案)，預期從 12 分鐘降到 378 毫秒。
*   **持續優化**：監控 Linting 總時間、CI/CD 執行時間、開發者回饋速度和錯誤檢出率。

---

### **8. Void0 背景，以及可以期待的內容**

Oxlint 只是 Oxidation Compiler 計劃中八個 JavaScript 工具之一，該計劃還包括壓縮器 (minifier)、格式化工具 (formatter) 和全新的 JavaScript 引擎。

由 Evan You 領導的 Void Zero 團隊，連同 Oxlint、Roll Down 和 TSO down，正在打造 Rust 驅動的 JavaScript 工具鏈復仇者聯盟，這是一個相當雄心勃勃的計劃。影片作者對這個發展方向表示興趣，特別是想看看他們如何利用這些工具來償還 460 萬美元的投資。

---

### **9. 總結與行動建議**

讓我來總結今天的三個核心要點：
1.  **MonoRepo 是趨勢** - 這是大型團隊的必然選擇。
2.  **pnpm 已勝出** - Lerna 時代已結束，pnpm Workspaces 成為主流。
3.  **OXC 是解決方案** - 能帶來數十倍性能提升。

**行動建議**：
*   **第一步**：今天就試用 pnpm + OXC，親自體驗性能提升。
*   **第二步**：評估你們團隊的 MonoRepo 工具選型。
*   **第三步**：制定漸進式遷移計畫。

**立即行動 (零風險)**：
1.  **安裝 Oxlint**：`npm install -D oxlint`。
2.  **修改一行配置**：`"lint": "oxlint && [原有指令]"`。
3.  **享受立即效能提升**：50-100 倍速度提升。

**持續關注 (準備升級)**：
1.  **追蹤 Nx 2025 路線圖**：Rust 核心重寫。
2.  **關注社群發展**：`@nx-community/oxlint`。
3.  **準備無縫升級**：配置向前兼容。

**風險保證**：
*   ✅ **零破壞性**：可隨時回退。
*   ✅ **向前兼容**：未來升級只需修改一行。
*   ✅ **漸進式採用**：從測試到正式使用。
*   ✅ **完整生態**：保留 ESLint 的所有功能。

效率革命從選對工具開始！感謝大家的聆聽，接下來我們有時間進行 Q&A 討論。

---
